{
    "almanac.device.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "almanac.service.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "audit.query": {
        "description": "Query audit requests.", 
        "params": {
            "auditorPHIDs": "optional list<phid>", 
            "commitPHIDs": "optional list<phid>", 
            "limit": "optional int (default = 100)", 
            "offset": "optional int", 
            "status": "optional string-constant<\"audit-status-any\", \"audit-status-open\", \"audit-status-concern\", \"audit-status-accepted\", \"audit-status-partial\"> (default = \"audit-status-any\")"
        }, 
        "return": "list<dict>"
    }, 
    "auth.logout": {
        "description": "Terminate all web login sessions. If called via OAuth, also terminate the current OAuth token.\n\nWARNING: This method does what it claims on the label. If you call this method via the test console in the web UI, it will log you out!", 
        "params": [], 
        "return": "void"
    }, 
    "auth.querypublickeys": {
        "description": "Query public keys.", 
        "params": {
            "after": "optional string", 
            "before": "optional string", 
            "ids": "optional list<id>", 
            "keys": "optional list<string>", 
            "limit": "optional int (default = 100)", 
            "objectPHIDs": "optional list<phid>", 
            "phids": "optional list<phid>"
        }, 
        "return": "result-set"
    }, 
    "badges.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.", 
        "params": {
            "objectIdentifier": "optional id|phid|string", 
            "transactions": "list<map<string, wild>>"
        }, 
        "return": "map<string, wild>"
    }, 
    "badges.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "chatlog.query": {
        "description": "Retrieve chatter.", 
        "params": {
            "channels": "optional list<string>", 
            "limit": "optional int (default = 100)"
        }, 
        "return": "nonempty list<dict>"
    }, 
    "chatlog.record": {
        "description": "Record chatter.", 
        "params": {
            "logs": "required list<dict>"
        }, 
        "return": "list<id>"
    }, 
    "conduit.connect": {
        "description": "Connect a session-based client.", 
        "params": {
            "authSignature": "optional string", 
            "authToken": "optional int", 
            "client": "required string", 
            "clientDescription": "optional string", 
            "clientVersion": "required int", 
            "host": "deprecated", 
            "user": "optional string"
        }, 
        "return": "dict<string, any>"
    }, 
    "conduit.getcapabilities": {
        "description": "List capabilities, wire formats, and authentication protocols available on this server.", 
        "params": [], 
        "return": "dict<string, any>"
    }, 
    "conduit.getcertificate": {
        "description": "Retrieve certificate information for a user.", 
        "params": {
            "host": "required string", 
            "token": "required string"
        }, 
        "return": "dict<string, any>"
    }, 
    "conduit.ping": {
        "description": "Basic ping for monitoring or a health-check.", 
        "params": [], 
        "return": "string"
    }, 
    "conduit.query": {
        "description": "Returns the parameters of the Conduit methods.", 
        "params": [], 
        "return": "dict<dict>"
    }, 
    "conpherence.createthread": {
        "description": "Create a new conpherence thread.", 
        "params": {
            "message": "required string", 
            "participantPHIDs": "required list<phids>", 
            "title": "optional string"
        }, 
        "return": "nonempty dict"
    }, 
    "conpherence.querythread": {
        "description": "Query for Conpherence threads for the logged in user. You can query by IDs or PHIDs for specific Conpherence threads. Otherwise, specify limit and offset to query the most recently updated Conpherences for the logged in user.", 
        "params": {
            "ids": "optional array<int>", 
            "limit": "optional int", 
            "offset": "optional int", 
            "phids": "optional array<phids>"
        }, 
        "return": "nonempty dict"
    }, 
    "conpherence.querytransaction": {
        "description": "Query for transactions for the logged in user within a specific Conpherence room. You can specify the room by ID or PHID. Otherwise, specify limit and offset to query the most recent transactions within the Conpherence room for the logged in user.", 
        "params": {
            "limit": "optional int", 
            "offset": "optional int", 
            "roomID": "optional int", 
            "roomPHID": "optional phid"
        }, 
        "return": "nonempty dict"
    }, 
    "conpherence.updatethread": {
        "description": "Update an existing conpherence room.", 
        "params": {
            "addParticipantPHIDs": "optional list<phids>", 
            "id": "optional int", 
            "message": "optional string", 
            "phid": "optional phid", 
            "removeParticipantPHID": "optional phid", 
            "title": "optional string"
        }, 
        "return": "bool"
    }, 
    "differential.close": {
        "description": "Close a Differential revision.", 
        "params": {
            "revisionID": "required int"
        }, 
        "return": "void"
    }, 
    "differential.createcomment": {
        "description": "Add a comment to a Differential revision.", 
        "params": {
            "action": "optional string", 
            "attach_inlines": "optional bool", 
            "message": "optional string", 
            "revision_id": "required revisionid", 
            "silent": "optional bool"
        }, 
        "return": "nonempty dict"
    }, 
    "differential.creatediff": {
        "description": "Create a new Differential diff.", 
        "params": {
            "authorPHID": "deprecated", 
            "bookmark": "optional string", 
            "branch": "required string", 
            "changes": "required list<dict>", 
            "creationMethod": "optional string", 
            "lintStatus": "required string-constant<\"none\", \"skip\", \"okay\", \"warn\", \"fail\">", 
            "parentRevisionID": "deprecated", 
            "repositoryPHID": "optional phid", 
            "repositoryUUID": "deprecated", 
            "sourceControlBaseRevision": "required string", 
            "sourceControlPath": "required string", 
            "sourceControlSystem": "required string-constant<\"svn\", \"git\", \"hg\">", 
            "sourceMachine": "required string", 
            "sourcePath": "required string", 
            "unitStatus": "required string-constant<\"none\", \"skip\", \"okay\", \"warn\", \"fail\">"
        }, 
        "return": "nonempty dict"
    }, 
    "differential.createinline": {
        "description": "Add an inline comment to a Differential revision.", 
        "params": {
            "content": "required string", 
            "diffID": "optional diffid", 
            "filePath": "required string", 
            "isNewFile": "required bool", 
            "lineLength": "optional int", 
            "lineNumber": "required int", 
            "revisionID": "optional revisionid"
        }, 
        "return": "nonempty dict"
    }, 
    "differential.createrawdiff": {
        "description": "Create a new Differential diff from a raw diff source.", 
        "params": {
            "diff": "required string", 
            "repositoryPHID": "optional string", 
            "viewPolicy": "optional string"
        }, 
        "return": "nonempty dict"
    }, 
    "differential.createrevision": {
        "description": "Create a new Differential revision.", 
        "params": {
            "diffid": "required diffid", 
            "fields": "required dict", 
            "user": "ignored"
        }, 
        "return": "nonempty dict"
    }, 
    "differential.find": {
        "description": "Query Differential revisions which match certain criteria.", 
        "params": {
            "guids": "required nonempty list<guids>", 
            "query": "required string-constant<\"open\", \"committable\", \"revision-ids\", \"phids\">"
        }, 
        "return": "nonempty list<dict>"
    }, 
    "differential.getalldiffs": {
        "description": "Load all diffs for given revisions from Differential.", 
        "params": {
            "revision_ids": "required list<int>"
        }, 
        "return": "dict"
    }, 
    "differential.getcommitmessage": {
        "description": "Retrieve Differential commit messages or message templates.", 
        "params": {
            "edit": "optional string-constant<\"edit\", \"create\">", 
            "fields": "optional dict<string, wild>", 
            "revision_id": "optional revision_id"
        }, 
        "return": "nonempty string"
    }, 
    "differential.getcommitpaths": {
        "description": "Query which paths should be included when committing a Differential revision.", 
        "params": {
            "revision_id": "required int"
        }, 
        "return": "nonempty list<string>"
    }, 
    "differential.getdiff": {
        "description": "Load the content of a diff from Differential by revision ID or diff ID.", 
        "params": {
            "diff_id": "optional id", 
            "revision_id": "optional id"
        }, 
        "return": "nonempty dict"
    }, 
    "differential.getrawdiff": {
        "description": "Retrieve a raw diff", 
        "params": {
            "diffID": "required diffID"
        }, 
        "return": "nonempty string"
    }, 
    "differential.getrevision": {
        "description": "Load the content of a revision from Differential.", 
        "params": {
            "revision_id": "required id"
        }, 
        "return": "nonempty dict"
    }, 
    "differential.getrevisioncomments": {
        "description": "Retrieve Differential Revision Comments.", 
        "params": {
            "ids": "required list<int>", 
            "inlines": "optional bool (deprecated)"
        }, 
        "return": "nonempty list<dict<string, wild>>"
    }, 
    "differential.parsecommitmessage": {
        "description": "Parse commit messages for Differential fields.", 
        "params": {
            "corpus": "required string", 
            "partial": "optional bool"
        }, 
        "return": "nonempty dict"
    }, 
    "differential.query": {
        "description": "Query Differential revisions which match certain criteria.", 
        "params": {
            "authors": "optional list<phid>", 
            "branches": "optional list<string>", 
            "ccs": "optional list<phid>", 
            "commitHashes": "optional list<pair<string-constant<\"gtcm\", \"gttr\", \"hgcm\">, string>>", 
            "ids": "optional list<uint>", 
            "limit": "optional uint", 
            "offset": "optional uint", 
            "order": "optional string-constant<\"order-modified\", \"order-created\">", 
            "paths": "optional list<pair<callsign, path>>", 
            "phids": "optional list<phid>", 
            "responsibleUsers": "optional list<phid>", 
            "reviewers": "optional list<phid>", 
            "status": "optional string-constant<\"status-any\", \"status-open\", \"status-accepted\", \"status-closed\">", 
            "subscribers": "optional list<phid>"
        }, 
        "return": "list<dict>"
    }, 
    "differential.querydiffs": {
        "description": "Query differential diffs which match certain criteria.", 
        "params": {
            "ids": "optional list<uint>", 
            "revisionIDs": "optional list<uint>"
        }, 
        "return": "list<dict>"
    }, 
    "differential.setdiffproperty": {
        "description": "Attach properties to Differential diffs.", 
        "params": {
            "data": "required string", 
            "diff_id": "required diff_id", 
            "name": "required string"
        }, 
        "return": "void"
    }, 
    "differential.updaterevision": {
        "description": "Update a Differential revision.", 
        "params": {
            "diffid": "required diffid", 
            "fields": "required dict", 
            "id": "required revisionid", 
            "message": "required string"
        }, 
        "return": "nonempty dict"
    }, 
    "diffusion.blame": {
        "description": "Get blame information for a list of paths.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "paths": "required list<string>", 
            "repository": "optional string", 
            "timeout": "optional int"
        }, 
        "return": "map<string, wild>"
    }, 
    "diffusion.branchquery": {
        "description": "Determine what branches exist for a repository.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "closed": "optional bool", 
            "contains": "optional string", 
            "limit": "optional int", 
            "offset": "optional int", 
            "repository": "optional string"
        }, 
        "return": "list<dict>"
    }, 
    "diffusion.browsequery": {
        "description": "File(s) information for a repository at an (optional) path and (optional) commit.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "optional string", 
            "limit": "optional int", 
            "needValidityOnly": "optional bool", 
            "offset": "optional int", 
            "path": "optional string", 
            "repository": "optional string"
        }, 
        "return": "array"
    }, 
    "diffusion.commitparentsquery": {
        "description": "Get the commit identifiers for a commit's parent or parents.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "repository": "optional string"
        }, 
        "return": "list<string>"
    }, 
    "diffusion.createcomment": {
        "description": "Add a comment to a Diffusion commit. By specifying an action of \"concern\", \"accept\", \"resign\", or \"close\", auditing actions can be triggered. Defaults to \"comment\".", 
        "params": {
            "action": "optional string", 
            "message": "required string", 
            "phid": "required string", 
            "silent": "optional bool"
        }, 
        "return": "bool"
    }, 
    "diffusion.diffquery": {
        "description": "Get diff information from a repository for a specific path at an (optional) commit.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "optional string", 
            "path": "required string", 
            "repository": "optional string"
        }, 
        "return": "array"
    }, 
    "diffusion.existsquery": {
        "description": "Determine if code exists in a version control system.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "repository": "optional string"
        }, 
        "return": "bool"
    }, 
    "diffusion.filecontentquery": {
        "description": "Retrieve file content from a repository.", 
        "params": {
            "branch": "optional string", 
            "byteLimit": "optional int", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "path": "required string", 
            "repository": "optional string", 
            "timeout": "optional int"
        }, 
        "return": "array"
    }, 
    "diffusion.findsymbols": {
        "description": "Retrieve Diffusion symbol information.", 
        "params": {
            "context": "optional string", 
            "language": "optional string", 
            "name": "optional string", 
            "namePrefix": "optional string", 
            "repositoryPHID": "optional string", 
            "type": "optional string"
        }, 
        "return": "nonempty list<dict>"
    }, 
    "diffusion.getlintmessages": {
        "description": "Get lint messages for existing code.", 
        "params": {
            "branch": "required string", 
            "commit": "optional string", 
            "files": "required list<string>", 
            "repositoryPHID": "required phid"
        }, 
        "return": "list<dict>"
    }, 
    "diffusion.getrecentcommitsbypath": {
        "description": "Get commit identifiers for recent commits affecting a given path.", 
        "params": {
            "branch": "optional string", 
            "callsign": "required string", 
            "limit": "optional int", 
            "path": "required string"
        }, 
        "return": "nonempty list<string>"
    }, 
    "diffusion.historyquery": {
        "description": "Returns history information for a repository at a specific commit and path.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "limit": "required int", 
            "needChildChanges": "optional bool", 
            "needDirectChanges": "optional bool", 
            "offset": "required int", 
            "path": "required string", 
            "repository": "optional string"
        }, 
        "return": "array"
    }, 
    "diffusion.internal.gitrawdiffquery": {
        "description": "Internal method for getting raw diff information.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "repository": "optional string"
        }, 
        "return": "string"
    }, 
    "diffusion.lastmodifiedquery": {
        "description": "Get the commits at which paths were last modified.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "paths": "required map<string, string>", 
            "repository": "optional string"
        }, 
        "return": "map<string, string>"
    }, 
    "diffusion.looksoon": {
        "description": "Advises Phabricator to look for new commits in a repository as soon as possible. This advice is most useful if you have just pushed new commits to that repository.", 
        "params": {
            "callsigns": "optional list<string> (deprecated)", 
            "repositories": "optional list<string>", 
            "urgency": "optional string"
        }, 
        "return": "void"
    }, 
    "diffusion.mergedcommitsquery": {
        "description": "Merged commit information for a specific commit in a repository.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "limit": "optional int", 
            "repository": "optional string"
        }, 
        "return": "array"
    }, 
    "diffusion.querycommits": {
        "description": "Retrieve information about commits.", 
        "params": {
            "after": "optional string", 
            "before": "optional string", 
            "bypassCache": "optional bool", 
            "ids": "optional list<int>", 
            "limit": "optional int (default = 100)", 
            "names": "optional list<string>", 
            "needMessages": "optional bool", 
            "phids": "optional list<phid>", 
            "repositoryPHID": "optional phid"
        }, 
        "return": "map<string, dict>"
    }, 
    "diffusion.querypaths": {
        "description": "Filename search on a repository.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "limit": "optional int", 
            "offset": "optional int", 
            "path": "required string", 
            "pattern": "optional string", 
            "repository": "optional string"
        }, 
        "return": "list<string>"
    }, 
    "diffusion.rawdiffquery": {
        "description": "Get raw diff information from a repository for a specific commit at an (optional) path.", 
        "params": {
            "againstCommit": "optional string", 
            "branch": "optional string", 
            "byteLimit": "optional int", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "linesOfContext": "optional int", 
            "path": "optional string", 
            "repository": "optional string", 
            "timeout": "optional int"
        }, 
        "return": "string"
    }, 
    "diffusion.refsquery": {
        "description": "Query a git repository for ref information at a specific commit.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "required string", 
            "repository": "optional string"
        }, 
        "return": "array"
    }, 
    "diffusion.repository.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.", 
        "params": {
            "objectIdentifier": "optional id|phid|string", 
            "transactions": "list<map<string, wild>>"
        }, 
        "return": "map<string, wild>"
    }, 
    "diffusion.repository.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "diffusion.resolverefs": {
        "description": "Resolve references into stable, canonical identifiers.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "refs": "required list<string>", 
            "repository": "optional string", 
            "types": "optional list<string>"
        }, 
        "return": "dict<string, list<dict<string, wild>>>"
    }, 
    "diffusion.searchquery": {
        "description": "Search (grep) a repository at a specific path and commit.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "optional string", 
            "grep": "required string", 
            "limit": "optional int", 
            "offset": "optional int", 
            "path": "required string", 
            "repository": "optional string"
        }, 
        "return": "array"
    }, 
    "diffusion.tagsquery": {
        "description": "Retrieve information about tags in a repository.", 
        "params": {
            "branch": "optional string", 
            "callsign": "optional string (deprecated)", 
            "commit": "optional string", 
            "limit": "optional int", 
            "names": "optional list<string>", 
            "needMessages": "optional bool", 
            "offset": "optional int", 
            "repository": "optional string"
        }, 
        "return": "array"
    }, 
    "diffusion.updatecoverage": {
        "description": "Publish coverage information for a repository.", 
        "params": {
            "branch": "required string", 
            "commit": "required string", 
            "coverage": "required map<string, string>", 
            "mode": "optional string-constant<\"overwrite\", \"update\">", 
            "repositoryPHID": "required phid"
        }, 
        "return": "void"
    }, 
    "diffusion.uri.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.", 
        "params": {
            "objectIdentifier": "optional id|phid|string", 
            "transactions": "list<map<string, wild>>"
        }, 
        "return": "map<string, wild>"
    }, 
    "feed.publish": {
        "description": "Publish a story to the feed.", 
        "params": {
            "data": "required dict", 
            "time": "optional int", 
            "type": "required string"
        }, 
        "return": "nonempty phid"
    }, 
    "feed.query": {
        "description": "Query the feed for stories", 
        "params": {
            "after": "optional int", 
            "before": "optional int", 
            "filterPHIDs": "optional list <phid>", 
            "limit": "optional int (default 100)", 
            "view": "optional string (data, html, html-summary, text)"
        }, 
        "return": "nonempty dict"
    }, 
    "file.allocate": {
        "description": "Prepare to upload a file.", 
        "params": {
            "contentHash": "optional string", 
            "contentLength": "int", 
            "deleteAfterEpoch": "optional int", 
            "name": "string", 
            "viewPolicy": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "file.download": {
        "description": "Download a file from the server.", 
        "params": {
            "phid": "required phid"
        }, 
        "return": "nonempty base64-bytes"
    }, 
    "file.info": {
        "description": "Get information about a file.", 
        "params": {
            "id": "optional id", 
            "phid": "optional phid"
        }, 
        "return": "nonempty dict"
    }, 
    "file.querychunks": {
        "description": "Get information about file chunks.", 
        "params": {
            "filePHID": "phid"
        }, 
        "return": "list<wild>"
    }, 
    "file.upload": {
        "description": "Upload a file to the server.", 
        "params": {
            "canCDN": "optional bool", 
            "data_base64": "required nonempty base64-bytes", 
            "name": "optional string", 
            "viewPolicy": "optional valid policy string or <phid>"
        }, 
        "return": "nonempty guid"
    }, 
    "file.uploadchunk": {
        "description": "Upload a chunk of file data to the server.", 
        "params": {
            "byteStart": "int", 
            "data": "string", 
            "dataEncoding": "string", 
            "filePHID": "phid"
        }, 
        "return": "void"
    }, 
    "file.uploadhash": {
        "description": "Upload a file to the server using content hash.", 
        "params": {
            "hash": "required nonempty string", 
            "name": "required nonempty string"
        }, 
        "return": "phid or null"
    }, 
    "flag.delete": {
        "description": "Clear a flag.", 
        "params": {
            "id": "optional id", 
            "objectPHID": "optional phid"
        }, 
        "return": "dict | null"
    }, 
    "flag.edit": {
        "description": "Create or modify a flag.", 
        "params": {
            "color": "optional int", 
            "note": "optional string", 
            "objectPHID": "required phid"
        }, 
        "return": "dict"
    }, 
    "flag.query": {
        "description": "Query flag markers.", 
        "params": {
            "limit": "optional int (default = 100)", 
            "objectPHIDs": "optional list<phid>", 
            "offset": "optional int", 
            "ownerPHIDs": "optional list<phid>", 
            "types": "optional list<type>"
        }, 
        "return": "list<dict>"
    }, 
    "harbormaster.createartifact": {
        "description": "Use this method to attach artifacts to build targets while running builds. Artifacts can be used to carry data through a complex build workflow, provide extra information to users, or store build results.\n\nWhen creating an artifact, you will choose an `artifactType` from this table. These types of artifacts are supported:\n| Artifact Type | Name | Summary |\n|-------------|--------------|--------------|\n| `host` | **Drydock Host** | References a host lease from Drydock. |\n| `working-copy` | **Drydock Working Copy** | References a working copy lease from Drydock. |\n| `file` | **File** | Stores a reference to file data which has been uploaded to Phabricator. |\n| `uri` | **URI** | Stores a URI. |\n\nEach artifact also needs an `artifactKey`, which names the artifact. Finally, you will provide some `artifactData` to fill in the content of the artifact. The data you provide depends on what type of artifact you are creating.\nDrydock Host\n--------------------------\n\nReferences a host lease from Drydock.\n\nCreate an artifact of this type by passing `host` as the `artifactType`. When creating an artifact of this type, provide these parameters as a dictionary to `artifactData`:\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `drydockLeasePHID` | //string// | Drydock working copy lease to create an artifact from. |\nFor example:\n```lang=json\n{\n  \"drydockLeasePHID\": \"PHID-DRYL-abcdefghijklmnopqrst\"\n}\n\n```\nDrydock Working Copy\n--------------------------\n\nReferences a working copy lease from Drydock.\n\nCreate an artifact of this type by passing `working-copy` as the `artifactType`. When creating an artifact of this type, provide these parameters as a dictionary to `artifactData`:\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `drydockLeasePHID` | //string// | Drydock working copy lease to create an artifact from. |\nFor example:\n```lang=json\n{\n  \"drydockLeasePHID\": \"PHID-DRYL-abcdefghijklmnopqrst\"\n}\n\n```\nFile\n--------------------------\n\nStores a reference to file data which has been uploaded to Phabricator.\n\nCreate an artifact of this type by passing `file` as the `artifactType`. When creating an artifact of this type, provide these parameters as a dictionary to `artifactData`:\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `filePHID` | //string// | File to create an artifact from. |\nFor example:\n```lang=json\n{\n  \"filePHID\": \"PHID-FILE-abcdefghijklmnopqrst\"\n}\n\n```\nURI\n--------------------------\n\nStores a URI.\n\nWith `ui.external`, you can use this artifact type to add links to build results in an external build system.\n\nCreate an artifact of this type by passing `uri` as the `artifactType`. When creating an artifact of this type, provide these parameters as a dictionary to `artifactData`:\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `uri` | //string// | The URI to store. |\n| `name` | //optional string// | Optional label for this URI. |\n| `ui.external` | //optional bool// | If true, display this URI in the UI as an link to additional build details in an external build system. |\nFor example:\n```lang=json\n{\n  \"uri\": \"https://buildserver.mycompany.com/build/123/\",\n  \"name\": \"View External Build Results\",\n  \"ui.external\": true\n}\n\n```", 
        "params": {
            "artifactData": "map<string, wild>", 
            "artifactKey": "string", 
            "artifactType": "string", 
            "buildTargetPHID": "phid"
        }, 
        "return": "wild"
    }, 
    "harbormaster.queryautotargets": {
        "description": "Load or create build autotargets.", 
        "params": {
            "objectPHID": "phid", 
            "targetKeys": "list<string>"
        }, 
        "return": "map<string, phid>"
    }, 
    "harbormaster.querybuildables": {
        "description": "Query Harbormaster buildables.", 
        "params": {
            "after": "optional string", 
            "before": "optional string", 
            "buildablePHIDs": "optional list<phid>", 
            "containerPHIDs": "optional list<phid>", 
            "ids": "optional list<id>", 
            "limit": "optional int (default = 100)", 
            "manualBuildables": "optional bool", 
            "phids": "optional list<phid>"
        }, 
        "return": "wild"
    }, 
    "harbormaster.querybuilds": {
        "description": "Query Harbormaster builds.", 
        "params": {
            "after": "optional string", 
            "before": "optional string", 
            "buildPlanPHIDs": "optional list<phid>", 
            "buildStatuses": "optional list<string>", 
            "buildablePHIDs": "optional list<phid>", 
            "ids": "optional list<id>", 
            "limit": "optional int (default = 100)", 
            "phids": "optional list<phid>"
        }, 
        "return": "wild"
    }, 
    "harbormaster.sendmessage": {
        "description": "Send a message about the status of a build target to Harbormaster, notifying the application of build results in an external system.\n\nSending Messages\n================\nIf you run external builds, you can use this method to publish build results back into Harbormaster after the external system finishes work or as it makes progress.\n\nThe simplest way to use this method is to call it once after the build finishes with a `pass` or `fail` message. This will record the build result, and continue the next step in the build if the build was waiting for a result.\n\nWhen you send a status message about a build target, you can optionally include detailed `lint` or `unit` results alongside the message. See below for details.\n\nIf you want to report intermediate results but a build hasn't completed yet, you can use the `work` message. This message doesn't have any direct effects, but allows you to send additional data to update the progress of the build target. The target will continue waiting for a completion message, but the UI will update to show the progress which has been made.\n\nMessage Types\n=============\nWhen you send Harbormaster a message, you must include a `type`, which describes the overall state of the build. For example, use `pass` to tell Harbomaster that a build completed successfully.\n\nSupported message types are:\n\n| Type | Description |\n|--------------|--------------|\n| `pass` | Report that the target is complete, and the target has passed. |\n| `fail` | Report that the target is complete, and the target has failed. |\n| `work` | Report that work on the target is ongoing. This message can be used to report partial results during a build. |\n\nUnit Results\n============\nYou can report test results alongside a message. The simplest way to do this is to report all the results alongside a `pass` or `fail` message, but you can also send a `work` message to report intermediate results.\n\nTo provide unit test results, pass a list of results in the `unit` parameter. Each result shoud be a dictionary with these keys:\n\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `name` | //string// | Short test name, like \"ExampleTest\". |\n| `result` | //string// | Result of the test. |\n| `namespace` | //optional string// | Optional namespace for this test. This is organizational and is often a class or module name, like \"ExampleTestCase\". |\n| `engine` | //optional string// | Test engine running the test, like \"JavascriptTestEngine\". This primarily prevents collisions between tests with the same name in different test suites (for example, a Javascript test and a Python test). |\n| `duration` | //optional float or int// | Runtime duration of the test, in seconds. |\n| `path` | //optional string// | Path to the file where the test is declared, relative to the project root. |\n| `coverage` | //optional map<string, wild>// | Coverage information for this test. |\n| `details` | //optional string// | Additional human-readable information about the failure. |\n\nThe `result` parameter recognizes these test results:\n\n| Key | Name | Description |\n|-------------|--------------|--------------|\n| `pass` | **Pass** | The test passed. |\n| `fail` | **Fail** | The test failed. |\n| `skip` | **Skip** | The test was not executed. |\n| `broken` | **Broken** | The test failed in an abnormal or severe way. For example, the harness crashed instead of reporting a failure. |\n| `unsound` | **Unsound** | The test failed, but this change is probably not what broke it. For example, it might have already been failing. |\n\nThis is a simple, valid value for the `unit` parameter. It reports one passing test and one failing test:\n\n\n\n```lang=json\n[\n  {\n    \"name\": \"PassingTest\",\n    \"result\": \"pass\"\n  },\n  {\n    \"name\": \"FailingTest\",\n    \"result\": \"fail\"\n  }\n]\n```\n\nLint Results\n============\nLike unit test results, you can report lint results alongside a message. The `lint` parameter should contain results as a list of dictionaries with these keys:\n\n| Key | Type | Description |\n|-------------|--------------|--------------|\n| `name` | //string// | Short message name, like \"Syntax Error\". |\n| `code` | //string// | Lint message code identifying the type of message, like \"ERR123\". |\n| `severity` | //string// | Severity of the message. |\n| `path` | //string// | Path to the file containing the lint message, from the project root. |\n| `line` | //optional int// | Line number in the file where the text which triggered the message first appears. The first line of the file is line 1, not line 0. |\n| `char` | //optional int// | Byte position on the line where the text which triggered the message starts. The first byte on the line is byte 1, not byte 0. This position is byte-based (not character-based) because not all lintable files have a valid character encoding. |\n| `description` | //optional string// | Long explanation of the lint message. |\n\nThe `severity` parameter recognizes these severity levels:\n\n| Key | Name |\n|-------------|--------------|\n| `advice` | **Advice** |\n| `autofix` | **Auto-Fix** |\n| `warning` | **Warning** |\n| `error` | **Error** |\n| `disabled` | **Disabled** |\n\nThis is a simple, valid value for the `lint` parameter. It reports one error and one warning:\n\n```lang=json\n[\n  {\n    \"name\": \"Syntax Error\",\n    \"code\": \"EXAMPLE1\",\n    \"severity\": \"error\",\n    \"path\": \"path/to/example.c\",\n    \"line\": 17,\n    \"char\": 3\n  },\n  {\n    \"name\": \"Not A Haiku\",\n    \"code\": \"EXAMPLE2\",\n    \"severity\": \"error\",\n    \"path\": \"path/to/source.cpp\",\n    \"line\": 23,\n    \"char\": 1,\n    \"description\": \"This function definition is not a haiku.\"\n  }\n]\n```\n\n", 
        "params": {
            "buildTargetPHID": "required phid", 
            "lint": "optional list<wild>", 
            "type": "required string-constant<\"pass\", \"fail\", \"work\">", 
            "unit": "optional list<wild>"
        }, 
        "return": "void"
    }, 
    "macro.creatememe": {
        "description": "Generate a meme.", 
        "params": {
            "lowerText": "optional string", 
            "macroName": "string", 
            "upperText": "optional string"
        }, 
        "return": "string"
    }, 
    "macro.query": {
        "description": "Retrieve image macro information.", 
        "params": {
            "authorPHIDs": "optional list<phid>", 
            "ids": "optional list<id>", 
            "nameLike": "optional string", 
            "names": "optional list<string>", 
            "phids": "optional list<phid>"
        }, 
        "return": "list<dict>"
    }, 
    "maniphest.createtask": {
        "description": "Create a new Maniphest task.", 
        "params": {
            "auxiliary": "optional dict", 
            "ccPHIDs": "optional list<phid>", 
            "description": "optional string", 
            "editPolicy": "optional phid or policy string", 
            "ownerPHID": "optional phid", 
            "priority": "optional int", 
            "projectPHIDs": "optional list<phid>", 
            "title": "required string", 
            "viewPolicy": "optional phid or policy string"
        }, 
        "return": "nonempty dict"
    }, 
    "maniphest.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.", 
        "params": {
            "objectIdentifier": "optional id|phid|string", 
            "transactions": "list<map<string, wild>>"
        }, 
        "return": "map<string, wild>"
    }, 
    "maniphest.gettasktransactions": {
        "description": "Retrieve Maniphest task transactions.", 
        "params": {
            "ids": "required list<int>"
        }, 
        "return": "nonempty list<dict<string, wild>>"
    }, 
    "maniphest.info": {
        "description": "Retrieve information about a Maniphest task, given its ID.", 
        "params": {
            "task_id": "required id"
        }, 
        "return": "nonempty dict"
    }, 
    "maniphest.query": {
        "description": "Execute complex searches for Maniphest tasks.", 
        "params": {
            "authorPHIDs": "optional list<phid>", 
            "ccPHIDs": "optional list<phid>", 
            "fullText": "optional string", 
            "ids": "optional list<uint>", 
            "limit": "optional int", 
            "offset": "optional int", 
            "order": "optional string-constant<\"order-priority\", \"order-created\", \"order-modified\">", 
            "ownerPHIDs": "optional list<phid>", 
            "phids": "optional list<phid>", 
            "projectPHIDs": "optional list<phid>", 
            "status": "optional string-constant<\"status-any\", \"status-open\", \"status-closed\", \"status-resolved\", \"status-wontfix\", \"status-invalid\", \"status-spite\", \"status-duplicate\">"
        }, 
        "return": "list"
    }, 
    "maniphest.querystatuses": {
        "description": "Retrieve information about possible Maniphest task status values.", 
        "params": [], 
        "return": "nonempty dict<string, wild>"
    }, 
    "maniphest.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "maniphest.update": {
        "description": "Update an existing Maniphest task.", 
        "params": {
            "auxiliary": "optional dict", 
            "ccPHIDs": "optional list<phid>", 
            "comments": "optional string", 
            "description": "optional string", 
            "editPolicy": "optional phid or policy string", 
            "id": "optional int", 
            "ownerPHID": "optional phid", 
            "phid": "optional int", 
            "priority": "optional int", 
            "projectPHIDs": "optional list<phid>", 
            "status": "optional string", 
            "title": "optional string", 
            "viewPolicy": "optional phid or policy string"
        }, 
        "return": "nonempty dict"
    }, 
    "owners.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.", 
        "params": {
            "objectIdentifier": "optional id|phid|string", 
            "transactions": "list<map<string, wild>>"
        }, 
        "return": "map<string, wild>"
    }, 
    "owners.query": {
        "description": "Query for Owners packages. Obsoleted by \"owners.search\".", 
        "params": {
            "path": "optional string", 
            "projectOwner": "optional string", 
            "repositoryCallsign": "optional string", 
            "userAffiliated": "optional string", 
            "userOwner": "optional string"
        }, 
        "return": "dict<phid -> dict of package info>"
    }, 
    "owners.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "passphrase.query": {
        "description": "Query credentials.", 
        "params": {
            "after": "optional string", 
            "before": "optional string", 
            "ids": "optional list<int>", 
            "limit": "optional int (default = 100)", 
            "needPublicKeys": "optional bool", 
            "needSecrets": "optional bool", 
            "order": "optional order", 
            "phids": "optional list<phid>"
        }, 
        "return": "list<dict>"
    }, 
    "paste.create": {
        "description": "Create a new paste.", 
        "params": {
            "content": "required string", 
            "language": "optional string", 
            "title": "optional string"
        }, 
        "return": "nonempty dict"
    }, 
    "paste.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.", 
        "params": {
            "objectIdentifier": "optional id|phid|string", 
            "transactions": "list<map<string, wild>>"
        }, 
        "return": "map<string, wild>"
    }, 
    "paste.info": {
        "description": "Retrieve an array of information about a paste.", 
        "params": {
            "paste_id": "required id"
        }, 
        "return": "nonempty dict"
    }, 
    "paste.query": {
        "description": "Query Pastes.", 
        "params": {
            "after": "optional int", 
            "authorPHIDs": "optional list<phid>", 
            "ids": "optional list<int>", 
            "limit": "optional int, default = 100", 
            "phids": "optional list<phid>"
        }, 
        "return": "list<dict>"
    }, 
    "paste.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "phame.blog.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.", 
        "params": {
            "objectIdentifier": "optional id|phid|string", 
            "transactions": "list<map<string, wild>>"
        }, 
        "return": "map<string, wild>"
    }, 
    "phame.blog.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "phame.post.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.", 
        "params": {
            "objectIdentifier": "optional id|phid|string", 
            "transactions": "list<map<string, wild>>"
        }, 
        "return": "map<string, wild>"
    }, 
    "phame.post.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "phid.info": {
        "description": "Retrieve information about an arbitrary PHID.", 
        "params": {
            "phid": "required phid"
        }, 
        "return": "nonempty dict<string, wild>"
    }, 
    "phid.lookup": {
        "description": "Look up objects by name.", 
        "params": {
            "names": "required list<string>"
        }, 
        "return": "nonempty dict<string, wild>"
    }, 
    "phid.query": {
        "description": "Retrieve information about arbitrary PHIDs.", 
        "params": {
            "phids": "required list<phid>"
        }, 
        "return": "nonempty dict<string, wild>"
    }, 
    "phragment.getpatch": {
        "description": "Retrieve the patches to apply for a given set of files.", 
        "params": {
            "path": "required string", 
            "state": "required dict<string, string>"
        }, 
        "return": "nonempty dict"
    }, 
    "phragment.queryfragments": {
        "description": "Query fragments based on their paths.", 
        "params": {
            "paths": "required list<string>"
        }, 
        "return": "nonempty dict"
    }, 
    "phrequent.pop": {
        "description": "Stop tracking time on an object by popping it from the stack.", 
        "params": {
            "note": "string", 
            "objectPHID": "phid", 
            "stopTime": "int"
        }, 
        "return": "phid"
    }, 
    "phrequent.push": {
        "description": "Start tracking time on an object by pushing it on the tracking stack.", 
        "params": {
            "objectPHID": "required phid", 
            "startTime": "int"
        }, 
        "return": "phid"
    }, 
    "phrequent.tracking": {
        "description": "Returns current objects being tracked in Phrequent.", 
        "params": [], 
        "return": "array"
    }, 
    "phriction.create": {
        "description": "Create a Phriction document.", 
        "params": {
            "content": "required string", 
            "description": "optional string", 
            "slug": "required string", 
            "title": "required string"
        }, 
        "return": "nonempty dict"
    }, 
    "phriction.edit": {
        "description": "Update a Phriction document.", 
        "params": {
            "content": "optional string", 
            "description": "optional string", 
            "slug": "required string", 
            "title": "optional string"
        }, 
        "return": "nonempty dict"
    }, 
    "phriction.history": {
        "description": "Retrieve history about a Phriction document.", 
        "params": {
            "slug": "required string"
        }, 
        "return": "nonempty list"
    }, 
    "phriction.info": {
        "description": "Retrieve information about a Phriction document.", 
        "params": {
            "slug": "required string"
        }, 
        "return": "nonempty dict"
    }, 
    "project.create": {
        "description": "Create a project.", 
        "params": {
            "color": "optional string", 
            "icon": "optional string", 
            "members": "optional list<phid>", 
            "name": "required string", 
            "tags": "optional list<string>"
        }, 
        "return": "dict"
    }, 
    "project.edit": {
        "description": "This is a standard **ApplicationEditor** method which allows you to create and modify objects by applying transactions. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Edit Endpoints ]]**.", 
        "params": {
            "objectIdentifier": "optional id|phid|string", 
            "transactions": "list<map<string, wild>>"
        }, 
        "return": "map<string, wild>"
    }, 
    "project.query": {
        "description": "Execute searches for Projects.", 
        "params": {
            "colors": "optional list<string>", 
            "icons": "optional list<string>", 
            "ids": "optional list<int>", 
            "limit": "optional int", 
            "members": "optional list<phid>", 
            "names": "optional list<string>", 
            "offset": "optional int", 
            "phids": "optional list<phid>", 
            "slugs": "optional list<string>", 
            "status": "optional string-constant<\"status-any\", \"status-open\", \"status-closed\", \"status-active\", \"status-archived\">"
        }, 
        "return": "list"
    }, 
    "project.search": {
        "description": "This is a standard **ApplicationSearch** method which will let you list, query, or search for objects. For documentation on these endpoints, see **[[ https://secure.phabricator.com/diviner/find/?name=Conduit+API%3A+Using+Edit+Endpoints&type=article&jump=1 | Conduit API: Using Search Endpoints ]]**.", 
        "params": {
            "after": "optional string", 
            "attachments": "optional map<string, bool>", 
            "before": "optional string", 
            "constraints": "optional map<string, wild>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "queryKey": "optional string"
        }, 
        "return": "map<string, wild>"
    }, 
    "releeph.getbranches": {
        "description": "Return information about all active Releeph branches.", 
        "params": [], 
        "return": "nonempty list<dict<string, wild>>"
    }, 
    "releeph.querybranches": {
        "description": "Query information about Releeph branches.", 
        "params": {
            "after": "optional string", 
            "before": "optional string", 
            "ids": "optional list<id>", 
            "limit": "optional int (default = 100)", 
            "phids": "optional list<phid>", 
            "productPHIDs": "optional list<phid>"
        }, 
        "return": "query-results"
    }, 
    "releeph.queryproducts": {
        "description": "Query information about Releeph products.", 
        "params": {
            "after": "optional string", 
            "before": "optional string", 
            "ids": "optional list<id>", 
            "isActive": "optional bool", 
            "limit": "optional int (default = 100)", 
            "phids": "optional list<phid>", 
            "repositoryPHIDs": "optional list<phid>"
        }, 
        "return": "query-results"
    }, 
    "releeph.queryrequests": {
        "description": "Return information about all Releeph requests linked to the given ids.", 
        "params": {
            "requestedCommitPHIDs": "optional list<phid>", 
            "revisionPHIDs": "optional list<phid>"
        }, 
        "return": "dict<string, wild>"
    }, 
    "releeph.request": {
        "description": "Request a commit or diff to be picked to a branch.", 
        "params": {
            "branchPHID": "required string", 
            "fields": "dict<string, string>", 
            "things": "required list<string>"
        }, 
        "return": "dict<string, wild>"
    }, 
    "releephwork.canpush": {
        "description": "Return whether the conduit user is allowed to push.", 
        "params": {
            "projectPHID": "required string"
        }, 
        "return": "bool"
    }, 
    "releephwork.getauthorinfo": {
        "description": "Return a string to use as the VCS author.", 
        "params": {
            "userPHID": "required string", 
            "vcsType": "required string"
        }, 
        "return": "nonempty string"
    }, 
    "releephwork.getbranch": {
        "description": "Return information to help checkout / cut a Releeph branch.", 
        "params": {
            "branchPHID": "required string"
        }, 
        "return": "dict<string, wild>"
    }, 
    "releephwork.getbranchcommitmessage": {
        "description": "Get a commit message for committing a Releeph branch.", 
        "params": {
            "branchPHID": "required string"
        }, 
        "return": "nonempty string"
    }, 
    "releephwork.getcommitmessage": {
        "description": "Get commit message components for building a ReleephRequest commit message.", 
        "params": {
            "action": "required string-constant<\"pick\", \"revert\">", 
            "requestPHID": "required string"
        }, 
        "return": "dict<string, string>"
    }, 
    "releephwork.nextrequest": {
        "description": "Return info required to cut a branch, and pick and revert ReleephRequests.", 
        "params": {
            "branchPHID": "required phid", 
            "seen": "required map<string, bool>"
        }, 
        "return": ""
    }, 
    "releephwork.record": {
        "description": "Record whether we committed a pick or revert to the upstream repository.", 
        "params": {
            "action": "required string-constant<\"pick\", \"revert\">", 
            "commitIdentifier": "required string", 
            "requestPHID": "required string"
        }, 
        "return": "void"
    }, 
    "releephwork.recordpickstatus": {
        "description": "Record whether a pick or revert was successful or not.", 
        "params": {
            "action": "required string-constant<\"pick\", \"revert\">", 
            "details": "optional dict<string, wild>", 
            "dryRun": "optional bool", 
            "ok": "required bool", 
            "requestPHID": "required string"
        }, 
        "return": ""
    }, 
    "remarkup.process": {
        "description": "Process text through remarkup in Phabricator context.", 
        "params": {
            "contents": "required list<string>", 
            "context": "required string-constant<\"phriction\", \"maniphest\", \"differential\", \"phame\", \"feed\", \"diffusion\">"
        }, 
        "return": "nonempty dict"
    }, 
    "repository.query": {
        "description": "Query repositories.", 
        "params": {
            "after": "optional string", 
            "before": "optional string", 
            "callsigns": "optional list<string>", 
            "ids": "optional list<int>", 
            "limit": "optional int (default = 100)", 
            "order": "optional order", 
            "phids": "optional list<phid>", 
            "remoteURIs": "optional list<string>", 
            "uuids": "optional list<string>", 
            "vcsTypes": "optional list<string>"
        }, 
        "return": "list<dict>"
    }, 
    "slowvote.info": {
        "description": "Retrieve an array of information about a poll.", 
        "params": {
            "poll_id": "required id"
        }, 
        "return": "nonempty dict"
    }, 
    "token.give": {
        "description": "Give or change a token.", 
        "params": {
            "objectPHID": "phid", 
            "tokenPHID": "phid|null"
        }, 
        "return": "void"
    }, 
    "token.given": {
        "description": "Query tokens given to objects.", 
        "params": {
            "authorPHIDs": "list<phid>", 
            "objectPHIDs": "list<phid>", 
            "tokenPHIDs": "list<phid>"
        }, 
        "return": "list<dict>"
    }, 
    "token.query": {
        "description": "Query tokens.", 
        "params": [], 
        "return": "list<dict>"
    }, 
    "user.disable": {
        "description": "Permanently disable specified users (admin only).", 
        "params": {
            "phids": "required list<phid>"
        }, 
        "return": "void"
    }, 
    "user.enable": {
        "description": "Re-enable specified users (admin only).", 
        "params": {
            "phids": "required list<phid>"
        }, 
        "return": "void"
    }, 
    "user.find": {
        "description": "Lookup PHIDs by username. Obsoleted by \"user.query\".", 
        "params": {
            "aliases": "required list<string>"
        }, 
        "return": "nonempty dict<string, phid>"
    }, 
    "user.query": {
        "description": "Query users.", 
        "params": {
            "emails": "optional list<string>", 
            "ids": "optional list<uint>", 
            "limit": "optional int (default = 100)", 
            "offset": "optional int", 
            "phids": "optional list<phid>", 
            "realnames": "optional list<string>", 
            "usernames": "optional list<string>"
        }, 
        "return": "list<dict>"
    }, 
    "user.whoami": {
        "description": "Retrieve information about the logged-in user.", 
        "params": [], 
        "return": "nonempty dict<string, wild>"
    }
}